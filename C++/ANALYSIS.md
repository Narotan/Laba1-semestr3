# АНАЛИЗ СТРУКТУР ДАННЫХ

## 1. ТАБЛИЦА СЛОЖНОСТИ ОПЕРАЦИЙ (BigO нотация)

| Структура данных | Операция | Временная сложность | Пространственная сложность | Комментарий |
|-----------------|----------|---------------------|---------------------------|-------------|
| **Динамический массив** | Добавление в конец (append) | O(1) амортизированная | O(n) | При переполнении - O(n) из-за копирования |
| | Вставка по индексу | O(n) | O(n) | Требуется сдвиг элементов |
| | Удаление по индексу | O(n) | O(1) | Сдвиг всех элементов после удаляемого |
| | Удаление по значению | O(n) | O(1) | Поиск + удаление |
| | Получение по индексу | O(1) | O(1) | Прямой доступ |
| | Поиск элемента | O(n) | O(1) | Линейный поиск |
| **Односвязный список** | Добавление в начало | O(1) | O(1) | Просто меняем указатель head |
| | Добавление в конец | O(n) | O(1) | Нужно пройти до конца |
| | Вставка после элемента | O(n) | O(1) | Поиск элемента O(n) + вставка O(1) |
| | Вставка перед элементом | O(n) | O(1) | Поиск предыдущего элемента |
| | Удаление головы | O(1) | O(1) | Просто меняем head |
| | Удаление хвоста | O(n) | O(1) | Нужно найти предпоследний элемент |
| | Удаление по значению | O(n) | O(1) | Поиск + удаление |
| | Поиск по значению | O(n) | O(1) | Проход по всему списку |
| | Получение по индексу | O(n) | O(1) | Последовательный проход |
| **Двусвязный список** | Добавление в начало | O(1) | O(1) | Меняем head и prev |
| | Добавление в конец | O(1) | O(1) | Меняем tail и next (благодаря указателю tail) |
| | Вставка после элемента | O(n) | O(1) | Поиск O(n) + вставка O(1) |
| | Вставка перед элементом | O(n) | O(1) | Поиск O(n) + вставка O(1) |
| | Удаление головы | O(1) | O(1) | Меняем head |
| | Удаление хвоста | O(1) | O(1) | Меняем tail (благодаря prev) |
| | Удаление по значению | O(n) | O(1) | Поиск + удаление |
| | Поиск по значению | O(n) | O(1) | Последовательный проход |
| **Стек** | Push (добавление) | O(1) амортизированная | O(n) | На основе динамического массива |
| | Pop (извлечение) | O(1) | O(1) | Удаление последнего элемента |
| | Peek (просмотр верхушки) | O(1) | O(1) | Чтение без удаления |
| | IsEmpty | O(1) | O(1) | Проверка размера |
| **Очередь** | Enqueue (добавление) | O(1) | O(1) | Добавление в конец двусвязного списка |
| | Dequeue (извлечение) | O(1) | O(1) | Удаление из начала списка |
| | IsEmpty | O(1) | O(1) | Проверка head |
| **AVL-дерево** | Вставка | O(log n) | O(1) | Самобалансировка при каждой вставке |
| | Удаление | O(log n) | O(1) | Самобалансировка после удаления |
| | Поиск | O(log n) | O(1) | Бинарный поиск по сбалансированному дереву |
| | Балансировка | O(1) | O(1) | Повороты - константное время |

---

## 2. ДОСТОИНСТВА И НЕДОСТАТКИ СТРУКТУР ДАННЫХ

### 2.1 Динамический массив

**Достоинства:**
- ✅ Быстрый доступ к элементам по индексу O(1)
- ✅ Простота реализации и использования
- ✅ Компактное хранение в памяти (непрерывный блок)
- ✅ Хорошая локальность данных (cache-friendly)
- ✅ Динамическое изменение размера

**Недостатки:**
- ❌ Вставка/удаление элементов в середине - O(n)
- ❌ Переаллокация памяти при росте массива
- ❌ Неэффективен для частых вставок/удалений
- ❌ Возможная фрагментация памяти

**Сфера применения:**
- Хранение коллекций с редкими изменениями
- Реализация буферов и кэшей
- Когда важен быстрый доступ по индексу
- Пример: список студентов в группе, история действий

---

### 2.2 Односвязный список

**Достоинства:**
- ✅ Быстрое добавление в начало O(1)
- ✅ Динамический размер без переаллокации
- ✅ Эффективное использование памяти (выделяется по мере надобности)
- ✅ Простая реализация

**Недостатки:**
- ❌ Нет прямого доступа к элементам O(n)
- ❌ Дополнительная память на указатели
- ❌ Удаление хвоста требует O(n)
- ❌ Невозможность обратного прохода
- ❌ Плохая локальность данных

**Сфера применения:**
- Реализация стека
- Списки с частыми вставками в начало
- Когда нужна экономия памяти (по сравнению с двусвязным)
- Пример: список задач, история команд (undo)

---

### 2.3 Двусвязный список

**Достоинства:**
- ✅ Быстрое добавление/удаление в начало и конец O(1)
- ✅ Возможность двунаправленного обхода
- ✅ Удаление элемента за O(1) при наличии указателя на него
- ✅ Динамический размер

**Недостатки:**
- ❌ Дополнительная память на два указателя на узел
- ❌ Нет прямого доступа к элементам O(n)
- ❌ Более сложная реализация
- ❌ Плохая локальность данных

**Сфера применения:**
- Реализация очереди (deque)
- Навигация вперёд-назад (браузер, плееры)
- LRU-кэш (Least Recently Used)
- Пример: история браузера, список воспроизведения с навигацией

---

### 2.4 Стек

**Достоинства:**
- ✅ Все операции O(1)
- ✅ Простая реализация
- ✅ Минимальные накладные расходы
- ✅ LIFO - естественная семантика для многих задач

**Недостатки:**
- ❌ Доступ только к верхнему элементу
- ❌ Нет доступа к элементам в середине
- ❌ Ограниченная функциональность

**Сфера применения:**
- Рекурсивные алгоритмы (вызовы функций)
- Проверка скобок, парсинг выражений
- Отмена операций (Undo)
- Обход графов в глубину (DFS)
- Пример: калькулятор с постфиксной нотацией, обработка скобочных последовательностей

---

### 2.5 Очередь

**Достоинства:**
- ✅ Все основные операции O(1)
- ✅ Простая реализация на базе двусвязного списка
- ✅ FIFO - справедливая обработка
- ✅ Естественна для моделирования процессов

**Недостатки:**
- ❌ Доступ только к первому элементу
- ❌ Нет произвольного доступа
- ❌ Ограниченная функциональность

**Сфера применения:**
- Планировщики задач
- Обработка запросов (очередь печати, сетевые пакеты)
- Буферизация данных
- Обход графов в ширину (BFS)
- Пример: очередь заявок, обработка сообщений, симуляция процессов

---

### 2.6 AVL-дерево

**Достоинства:**
- ✅ Гарантированный баланс (высота = O(log n))
- ✅ Все операции O(log n)
- ✅ Быстрый поиск, вставка, удаление
- ✅ Упорядоченное хранение данных
- ✅ Предсказуемая производительность

**Недостатки:**
- ❌ Сложная реализация (балансировка, повороты)
- ❌ Дополнительная память на хранение высоты
- ❌ Более медленная вставка/удаление по сравнению с несбалансированным деревом
- ❌ Накладные расходы на балансировку

**Сфера применения:**
- Когда нужен упорядоченный набор с быстрым поиском
- Индексы в базах данных
- Словари и множества
- Реализация priority queue
- Пример: телефонная книга, поиск в отсортированных данных, автодополнение

---

## 3. СРАВНИТЕЛЬНАЯ ТАБЛИЦА

| Критерий | Массив | Односвязный список | Двусвязный список | Стек | Очередь | AVL-дерево |
|----------|--------|-------------------|------------------|------|---------|-----------|
| **Доступ по индексу** | O(1) ⭐ | O(n) | O(n) | - | - | O(log n) |
| **Поиск** | O(n) | O(n) | O(n) | - | - | O(log n) ⭐ |
| **Вставка в начало** | O(n) | O(1) ⭐ | O(1) ⭐ | - | - | O(log n) |
| **Вставка в конец** | O(1)* | O(n) | O(1) ⭐ | O(1) ⭐ | O(1) ⭐ | O(log n) |
| **Удаление начала** | O(n) | O(1) ⭐ | O(1) ⭐ | - | O(1) ⭐ | O(log n) |
| **Удаление конца** | O(1) ⭐ | O(n) | O(1) ⭐ | O(1) ⭐ | - | O(log n) |
| **Память на элемент** | 1x ⭐ | 2x | 3x | 1x ⭐ | 3x | 3x |
| **Упорядоченность** | - | - | - | LIFO | FIFO | Sorted ⭐ |
| **Сложность реализации** | Простая ⭐ | Средняя | Средняя | Простая ⭐ | Простая | Сложная |

*O(1) амортизированная

⭐ - Преимущество в данной категории

---

## 4. РЕКОМЕНДАЦИИ ПО ВЫБОРУ

**Выбирайте массив**, если:
- Нужен частый доступ по индексу
- Размер коллекции известен заранее или меняется редко
- Важна компактность и локальность данных

**Выбирайте односвязный список**, если:
- Частые вставки/удаления в начале
- Экономия памяти важнее скорости
- Не нужен доступ по индексу

**Выбирайте двусвязный список**, если:
- Нужны операции с обоих концов
- Требуется двунаправленный обход
- Реализуете очередь или deque

**Выбирайте стек**, если:
- Нужна LIFO-семантика (последний пришёл - первый ушёл)
- Реализуете рекурсию или обработку вложенных структур

**Выбирайте очередь**, если:
- Нужна FIFO-семантика (первый пришёл - первый ушёл)
- Реализуете планировщик или буфер

**Выбирайте AVL-дерево**, если:
- Нужен быстрый поиск в упорядоченных данных
- Часто выполняется поиск, а не только вставка
- Важна предсказуемость времени выполнения

---

## 5. ВИЗУАЛЬНЫЕ ПРИМЕРЫ РАБОТЫ

### Массив
```
Начальное состояние: []
MPUSH myarr hello    → [hello]
MPUSH myarr world    → [hello, world]
MPUSH myarr test     → [hello, world, test]
MGET myarr 1         → world
MDEL myarr world     → [hello, test]
```

### Стек (LIFO)
```
SPUSH stack A   →  [A]
SPUSH stack B   →  [A, B]
SPUSH stack C   →  [A, B, C]
                         ↑ top
SPOP stack      →  C (результат: [A, B])
SPOP stack      →  B (результат: [A])
```

### Очередь (FIFO)
```
QPUSH queue A   →  [A]
QPUSH queue B   →  [A, B]
QPUSH queue C   →  [A, B, C]
                    ↑ front
QPOP queue      →  A (результат: [B, C])
QPOP queue      →  B (результат: [C])
```

### AVL-дерево (самобалансирующееся)
```
Вставка: 10, 5, 15, 3, 7

      10
     /  \
    5    15
   / \
  3   7

Поиск 7: TRUE
Поиск 20: FALSE
```

---

## 6. ОЦЕНКА ПАМЯТИ

| Структура | Память на N элементов | Overhead |
|-----------|----------------------|----------|
| Массив | N × sizeof(char*) + строки | Минимальный |
| Односвязный список | N × (sizeof(char*) + sizeof(Node*)) + строки | ~2x |
| Двусвязный список | N × (sizeof(char*) + 2×sizeof(Node*)) + строки | ~3x |
| Стек (на массиве) | N × sizeof(char*) + строки | Минимальный |
| Очередь (на списке) | N × (sizeof(char*) + 2×sizeof(Node*)) + строки | ~3x |
| AVL-дерево | N × (sizeof(int) + sizeof(height) + 2×sizeof(Node*)) | ~3x |

---

*Этот анализ основан на реализации в данном проекте*
